const fs = require("fs");
const path = require("path");

function applyIntrinsicFunctions(schema) {
  if (schema.properties) {
    schema.properties = applyCFStringFunctions(schema.properties)
  }
  if (schema.definitions) {
    schema.definitions = applyCFStringFunctions(schema.definitions)
  }
  return schema
}

function applyCFStringFunctions(obj) {
  Object.keys(obj).forEach((key) => {
    let val = obj[key];
    if (val.type === "string") {
      const {description} = val
      if (description) {
        delete val.description
      }
      val = {
        "oneOf": [
          {
            ...val
          },
          {
            "$ref": "../../components/cf.functions.json#/Aws_CF_FunctionString"
          }
        ]
      }
      if (description) {
        val.description = description
      }
      obj[key] = val
    } else if (val.type === "object") {
      if (
        obj[key].properties
      ) {
        obj[key].properties = applyCFStringFunctions(obj[key].properties)
      }
    }
  })
  return obj
}

/**
 * 
 * @param {string} dirName directory path full
 * @param {string} fileName name of the file
 * @param {string} schemaFileName name of the file
 */
function readAndMoveResourceFile(dirName, fileName, schemaFileName) {
  try {
      const schema = fs.readFileSync(
          path.join(dirName, fileName, schemaFileName)
      ).toString()
      fs.writeFileSync(
          path.join(
              __dirname,
              "serverless/resources/cloudformation",
              schemaFileName
          ),
          schema
      )
  } catch(err) {
      console.error(err)
      console.log("DW")
  }
}

/**
 * There are certain 3rd party resources that also support cloudformation
 * This function will pull the schemas and populate into the cloudformation Directory
 * Currently Supported Items:-
 * 1. MongoDB
 * 2. DataDog
 */
function getThirdPartySchemas() {
  const mongoDir = path.join(
    __dirname, 
    "serverless/resources/third-party-resources", 
    "mongodbatlas-cloudformation-resources", "cfn-resources"
  )
  fs.readdirSync(mongoDir).forEach(r => {
    const schemaFileName = `mongodb-atlas-${r.replaceAll('-', '')}.json`
    readAndMoveResourceFile(mongoDir, r, schemaFileName)
  })
  const datadogDir = path.join(
    __dirname, 
    "serverless/resources/third-party-resources", 
    "datadog-cloudformation-resources"
  )
  fs.readdirSync(datadogDir).forEach(r => {
    const schemaFileName = `${r.replaceAll('-handler', '')}.json`
    readAndMoveResourceFile(datadogDir, r, schemaFileName)
  })
}

(async () => {
    await getThirdPartySchemas()
    const sharedAttributes = {
        "DeletionPolicy": {
          "description": "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html",
          "type": "string",
          "enum": [
            "Delete",
            "Retain",
            "Snapshot"
          ]
        },
        "UpdateReplacePolicy": {
          "description": "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html",
          "type": "string",
          "enum": [
            "Delete",
            "Retain",
            "Snapshot"
          ]
        },
        "Metadata": {
          "description": "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html",
          "type": "object"
        },
        "CreationPolicy": {
          "description": "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-creationpolicy.html",
          "type": "object"
        },
        "UpdatePolicy": {
          "description": "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html",
          "type": "object"
        },
        "DependsOn": {
          "type": [
            "string",
            "array"
          ],
          "items": {
            "type": "string"
          }
        }
    }
    /**
     * These resource files are downloaded from cloudformation for us-east-1
     * https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resource-type-schemas.html
     */
    const resources = fs.readdirSync(path.join(__dirname, "serverless/resources/cloudformation"));
    const resourcesSchema = {
        $comment: "DO NOT EDIT THIS FILE DIRECTLY! PLEASE CHANGE THE INDIVIDUAL RESOURCE FILES AND THEN RUN THE SCRIPT TO GENERATE THIS FILE",
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://aws.amazon.com/cloudformation/resources.schema.json",
        definitions: {},
        description: "Auto generated schema from individual resource definition from Cloudformation",
        type: "object",
        properties: {}
    }
    for (const resource of resources) {
        let schema = require(`./serverless/resources/cloudformation/${resource}`);
        const resourceName = schema.typeName.split("::").join("")
        resourcesSchema.definitions[resourceName] = {
            title: resourceName,
            type: "object",
            additionalProperties: false,
            properties: {
                Type: {
                    type: "string",
                    enum: [
                        schema.typeName
                    ],
                },
                Properties: {
                  $ref: `cloudformation-modified/${resource}`
                },
                ...sharedAttributes
            },
            required: [
              "Type",
              "Properties"
            ]
        }
        schema.title = `${resourceName}Properties`
        schema.type = "object"
        let {description, sourceUrl} = schema
        if (!description) {
          description = "No description available"
        }
        if (!sourceUrl) {
          sourceUrl = "No source definition found, add manually please"
        }
        schema.description = `${description}. Source:- ${sourceUrl}`
        // delete handlers
        delete schema.handlers

        // modify properties so they would allow for Cloudformation functions
        schema = applyIntrinsicFunctions(schema)
        // remove readonly properties
        if (schema.readOnlyProperties) {
          schema.readOnlyProperties.forEach(rP => {
            const parts = rP.trim().split("/")
            const property = parts[parts.length - 1]
            if (schema.properties[property]) {
              delete schema.properties[property]
            }
          })
        }
        // Add title to every definition
        if (schema.definitions) {
          Object.keys(schema.definitions).forEach((key) => {
            if (schema.definitions[key]) {
              if (!schema.definitions[key].title) {
                let newTitle = `${resourceName}${key}`
                if (!newTitle.toLowerCase().trim().endsWith('definition')) {
                  newTitle += 'Definition'
                }
                schema.definitions[key].title = newTitle
              }
            }
          })
        }
        fs.writeFileSync(
            path.join(__dirname, `serverless/resources/cloudformation-modified/${resource}`),
            JSON.stringify(schema, null, 2)
        )
    }
    resourcesSchema.properties = {
        Resources: {
            type: "object",
            minProperties: 1,
            patternProperties: {
                "^[a-zA-Z0-9]{1,255}$": {
                    oneOf: Object.keys(resourcesSchema.definitions).map((d) => {
                        return {
                            $ref: "#/definitions/" + d
                        }
                    })
                }
            }
        }
    }
    fs.writeFileSync(
        path.join(__dirname, "serverless/resources/resources.schema.json"),
        JSON.stringify(resourcesSchema, null, 2)
    )
})()
